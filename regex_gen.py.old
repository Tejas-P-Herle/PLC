class RegexGen:

    def gen_regex(self):
        """Generate regex given differences and matches between strings"""

        # Define regex and index to store index and
        regex = ""
        i = 0

        # Run a while loop through all elements of the array
        while i in range(len(self.line_from)):

            # Iterate through all elements in differences dict
            # And check if current index in difference dict
            if i in self.diff_dict.keys():

                # Check if character is to be escaped
                if self.line_from[i] in self.escape_chars:

                    # Then add a preceding backslash
                    regex += "\\"

                # If yes, then copy text from start to end of diff
                regex += self.line_from[i]
            
            # Else it is in match list
            else:

                # Iterate through all ranges in match dictionary
                for rng in self.match_dict.keys():

                    # Check if current index is range start
                    if i == rng[0]:

                        # Then get next anticipated character
                        # Set default next anticipated character to white space
                        nxt_char = "\\n" if rng[1] == len(self.line_from) else ""

                        # Iterate through difference dict and check indexes
                        for j, char in self.diff_dict.items():
                            
                            # If index is greater than current character
                            # Then set it as next anticipated character
                            if i < j and char.strip():
                                nxt_char = char
                                
                                # Break out of loop to stop at immediate next character
                                break

                        # Check if next character is a null string
                        if nxt_char:

                            # Set regex to accept all characters
                            # Except next anticipated character
                            regex += "([^{}])*".format(nxt_char)

                        else:

                            # If is null string, get super sets for substring
                            super_sets = self.find_super_set(
                                self.line_from[rng[0]: rng[1]])

                            possible_matches = "(["
                            
                            # For super set add possible match
                            if super_sets & 1:

                                # If is an alphabet, add [a-z] to matches
                                possible_matches += "a-z"
                            
                            if super_sets & 2:
                                
                                # If is an alphabet(upper), add [A-Z] to matches
                                possible_matches += "A-Z"
                            
                            if super_sets & 4:
                                
                                # If is an number, add [0-9] to matches
                                possible_matches += "0-9"

                            if super_sets & 8:

                                # If has whitespace space(' '), add ' ' to matches
                                possible_matches += " "

                            if super_sets & 16:
                                # If is a sign, add all signs to matches
                                possible_matches += SIGNS.replace("\\", "\\\\").replace("-", "\-").replace("]", "\]")

                            possible_matches += "])"

                            # Check if possible matches is all or null
                            if possible_matches == "([])" or \
                                    not bin(super_sets)[2:].find("0"):

                                # Then set possible matches to .(all)
                                possible_matches = "(.)"
                            
                            # Add infinite number of matches to accept
                            possible_matches += "*"

                            # Add to final regex
                            regex += possible_matches

                        # Increment count by one less than matched characters
                        i = rng[1] - 1
                        
                        # Break out of loop
                        break    

            # Increment count by one
            i += 1

        # Return final regex
        return regex

    @staticmethod
    def find_super_set(substring):
        """Find super set for given input substring"""

        # Define super sets
        alphabets = "abcdefghijklmnopqrstuvwxyz"
        alphabets_upper = alphabets.upper()

        numbers = "0123456789"

        # Define variable to store find results
        res_bin = 0

        # Check if any character in sub string is persent in 
        # Either of the super sets
        for char in substring:

            # Check of superset alphabets
            if char in alphabets:

                # Set in alphabets bit to True
                res_bin |= 1

            # Check of superset alphabets
            if char in alphabets_upper:

                # Set in alphabets upper bit to True
                res_bin |= 2

            # Check of superset numbers
            if char in numbers:

                # Set in numbers bit to True
                res_bin |= 4

            # Check of superset whitespace space(' ')
            if char == " ":

                # Set has space bit to True
                res_bin |= 8

            # Check of superset signs (ie. !@#$%^&*(){}[]|\:;"'<>?,./~`)
            if char in SIGNS:

                # Set in signs bit to True
                res_bin |= 16

        # Return binary result
        return res_bin
    
